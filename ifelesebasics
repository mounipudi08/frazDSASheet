1)Write a C++ program to input amount from user and print minimum number of notes (Rs. 500, 100, 50, 20, 10, 5, 2, 1) required for the amount.
567890
Total Number of Notes
500 = 1135
100 = 3
50 = 1
20 = 2
10 = 0
5 = 0
2 = 0
1 = 0
1st Approach (my own)
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		List<Integer> notes = Arrays.asList(500, 100, 50, 20, 10, 5, 2, 1);
		List<Integer> value = new ArrayList<>();
		int amount;
		for(Integer note:notes){
			System.out.println(note);
			amount = n/note;
			n = n%note;
			value.add(amount);
            System.out.println("used" + note + " "+ "notes" + " "+ amount);
			}
			System.out.println(value);
2nd Approach 

import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] notes = {500, 100, 50, 20, 10, 5, 2, 1};
		int[] count = new int[8];
		int amount;
		for(int i=0;i<notes.length;i++){
			count[i] = n/notes[i];
			n = n%notes[i];
		}
		for(int i=0;i<notes.length;i++){
			System.out.println(notes[i] + " = "+ count[i]);
		}	
	}
}
Fraz approach
import java.util.Scanner;

public class CurrencyDenominations {
    public static void main(String[] args) {
        int amount;
        int note500, note100, note50, note20, note10, note5, note2, note1;

        // Initialize all notes to 0
        note500 = note100 = note50 = note20 = note10 = note5 = note2 = note1 = 0;

        // Input amount from user
        Scanner scanner = new Scanner(System.in);
       // System.out.print("Enter amount: ");
        amount = scanner.nextInt();

        // Calculate number of notes for each denomination
        if (amount >= 500) {
            note500 = amount / 500;
            amount -= note500 * 500;
        }
        if (amount >= 100) {
            note100 = amount / 100;
            amount -= note100 * 100;
        }
        if (amount >= 50) {
            note50 = amount / 50;
            amount -= note50 * 50;
        }
        if (amount >= 20) {
            note20 = amount / 20;
            amount -= note20 * 20;
        }
        if (amount >= 10) {
            note10 = amount / 10;
            amount -= note10 * 10;
        }
        if (amount >= 5) {
            note5 = amount / 5;
            amount -= note5 * 5;
        }
        if (amount >= 2) {
            note2 = amount / 2;
            amount -= note2 * 2;
        }
        if (amount >= 1) {
            note1 = amount;
        }

        // Print required notes
        System.out.println("Total number of notes:");
        System.out.println("500 = " + note500);
        System.out.println("100 = " + note100);
        System.out.println("50 = " + note50);
        System.out.println("20 = " + note20);
        System.out.println("10 = " + note10);
        System.out.println("5 = " + note5);
        System.out.println("2 = " + note2);
        System.out.println("1 = " + note1);

        // Close scanner resource
        scanner.close();
    }
}

2) check its an equilateral triangle or not 

import java.util.*;
public class Main {
	public static void main(String args[]){
		Scanner sc = new Scanner(System.in);
		int side1 = sc.nextInt();
		int side2 = sc.nextInt();
		int side3 = sc.nextInt();
		if((side1==side2) && (side2==side3)){
			System.out.println("Its a equilateral triangle");
		}
		else if(( side1 == side2) && (side2 == side3) && (side3 == side2)) {
			System.out.println("Isosceles triangle");
		}
		else {
				System.out.println("Scalene triangle");
		}
	}
}
3) Write a C++ program to input electricity unit charge and calculate the total electricity bill according to the given condition:
For first 50 units Rs. 0.50/unit
For next 100 units Rs. 0.75/unit
For next 100 units Rs. 1.20/unit
For unit above 250 Rs. 1.50/unit
An additional surcharge of 20% is added to the bill.

Input unit consumed by customer in some variable say unit.
If unit consumed less or equal to 50 units. Then amt = unit * 0.50.
If unit consumed more than 50 units but less than 100 units. Then add the first 50 units amount i.e. 25 to final amount and compute the rest 50 units amount. Which is given by amt = 25 + (unit-50) * 0.75. I have used units-50, since I already calculated first 50 units which is 25.
Similarly check rest of the conditions and calculate total amount.
After calculating total amount. Calculate the surcharge amount i.e. sur_charge = total_amt * 0.20. Add surcharge amount to net amount. Which is given by net_amt = total_amt + sur_charge.

import java.util.*;
public class Main {
	public static void main(String args[]){
		Scanner sc = new Scanner(System.in);
		int unit = sc.nextInt();
		float amount,totalamount,surCharge;
		if(unit <= 50){
			amount = unit*0.50f;
		}
		else if(unit <= 150){
			amount = 25 + (unit-50)*0.75f;
		}
		 else if(unit <= 250){
			amount = 100 + (unit-150)*1.20f;
		}
		else {
          amount = 220 + (unit-250)*1.50f;
		}
		surCharge = amount*0.20f;
		totalamount = amount + surCharge;
		System.out.println(totalamount);
	}
}
4)Write a C++ program to input a number and find the sum of first and last digit of the number using a for loop. 
import java.util.*;
public class Main {
	public static void main(String[] args) {
		// write your code here
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int lastdigit = n%10;
		while(n >= 10){
			n = n/10;
		}
		int sum = n+lastdigit;
		System.out.println(sum);
	}
}
5)Write a C++ program to input a number from the user and calculate product of its digits
import java.util.*;
public class Main {
	public static void main(String[] args) {
		// write your code here
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		long p = 1L;
		p = (n == 0) ? 0 : 1L;
		while(n != 0){
			p *= (n%10);
			n = n/10;
			System.out.println("num"+n);
			System.out.println("p"+p);
		}
		System.out.println(p);
	}
}
6) Write a C++ program to input number from user and check number is palindrome or not using loop. 
import java.util.*;
public class Main {
	public static void main(String[] args) {
		// write your code here
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int copy = n;
		int rev = 0;
		while(copy != 0){
			rev = rev*10 + copy % 10;
			copy = copy/10;
		}
		System.out.println(rev == n);
	}
}

7)Write a C++ program to find power of a number using for loop. 
base = 2
exponent = 5
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // Declare variables for base, exponent, and power
        int base, exponent;
        long power = 1;

        // Create a Scanner object for user input
        Scanner scanner = new Scanner(System.in);

        // Input base and exponent from the user
        // System.out.println("Enter base:");
        base = scanner.nextInt();
        // System.out.println("Enter exponent:");
        exponent = scanner.nextInt();

        // Multiply base by itself exponent times
        for (int i = 1; i <= exponent; i++) {
            power *= base;
        }

        // Display the result
        System.out.println(base + " ^ " + exponent + " = " + power);

        // Close the scanner to free up resources
        scanner.close();
    }
}

8)Write a C++ program to print Fibonacci series up to n terms using loop. 
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int a = 0;
		int b = 1;
	    System.out.println(a);
		System.out.println(b);
		while(n-2 > 0){
         int c = a+b;
		 System.out.println(c + " ");
		 a = b;
		 b = c;
		 n--;
		}
	}
}

9)Write a Program to input a number from user and find all factors of the given number using for loop.
import java.util.*;
public class Main {
	public static int squareroot(int n){
		int near = 0;
        for(int i=1;i<=n;i++){
			if(i*i == n){
				return i;
			}
			else if(i*i < n) {
				near = i;
			}
		}
		return near;
	}
	public static void main(String[] args) {
		// write your code here
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int square = squareroot(n);
		int count = 0;
		for(int i=1;i<=square;i++){
		 if(n%i == 0){
			if(i*i == n){
             count++;
		   }
           else{
			  System.out.println(i);
			  count=count+2;
		   }
			}
		}
		System.out.println(count);
	}
}

Approach:2 
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int square = (int) Math.sqrt(n);  // using inbuilt function
        int count = 0;

        for (int i = 1; i <= square; i++) {
            if (n % i == 0) {

                if (i == n / i) {
                    // Perfect square divisor
                    count += 1;
                } else {
                    // Pair divisors: i and n/i
                    count += 2;
                }
            }
        }

        System.out.println(count);
    }
}
import java.util.*;
public class Main {
	public static int squareroot(int n){
		int near = 0;
        for(int i=1;i*i<=n;i++){
			near = i;
		}
		return near;
	}
10)Write a program in C++ to input a number and check whether the number is prime number or not using for loop.

	public static boolean primeNumber(int n,int square){
		if(n <= 1) return false;// 0 and 1 are not a prime 
		for(int i=2;i<=square;i++){
		 if(n%i == 0){
		    return false;
		 }
		}
		return true;
	 }
	public static void main(String[] args) {
		// write your code here
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int square = squareroot(n);
		if(primeNumber(n,square) == true){
         System.out.println(n + " Is a prime number");
		}
		else {
         System.out.println(n + " Is not a prime number");
		}
	}
}
11)Write a C++ program to print all Prime numbers between 1 to n using loop
import java.util.*;
public class Main {
	public static boolean primeNumber(int n,int square){
		if(n <= 1) return false;// 0 and 1 are not a prime 
		for(int i=2;i<=square;i++){
		 if(n%i == 0){
		    return false;
		 }
		}
		return true;
	 }
	public static void main(String[] args) {
		// write your code here
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		for(int i=1;i<=n;i++){
		   int square = (int) Math.sqrt(i);
           if(primeNumber(i,square) == true){
             System.out.println(i);
		   }
		}
	}
}
12)Write a C++ program to input a number from user and find Prime factors of the given number using loop.

import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        System.out.println("Prime factors of " + n + " are:");

        // Check divisibility by 2
        while (n % 2 == 0) {
            System.out.println(2);
            n /= 2;
        }

        // Check odd numbers from 3 to sqrt(n)
        for (int i = 3; i * i <= n; i += 2) {
            while (n % i == 0) {
                System.out.println(i);
                n /= i;
            }
        }

        // Whatever is left > 2 must be a prime
        if (n > 2) {
            System.out.println(n);
        }
    }
}
Sure! I‚Äôll explain the **optimized prime factor logic** step-by-step using **24** and **48** so you understand **why every step is needed**.

---

# ‚≠ê First, understand the Goal

Prime factors = break the number into **only prime numbers** multiplied together.

Examples:
24 ‚Üí 2 √ó 2 √ó 2 √ó 3
48 ‚Üí 2 √ó 2 √ó 2 √ó 2 √ó 3

---

# ‚≠ê Now let‚Äôs go step-by-step through the optimized method

### üî• Step 1: Remove all factors of **2** first

Why?
Because **2 is the only even prime**.
If we divide out all 2‚Äôs now, the remaining number becomes **odd**.
‚Üí This reduces our loop by **half** (no need to check evens).

---

# ‚≠ê Example 1: Take **24**

### Step 1 ‚Äî Remove all 2's

```
24 % 2 == 0 ‚Üí print 2 ‚Üí n = 12  
12 % 2 == 0 ‚Üí print 2 ‚Üí n = 6  
6 % 2 == 0 ‚Üí print 2 ‚Üí n = 3  
3 % 2 != 0 ‚Üí stop
```

So far prime factors:

```
2
2
2
```

Now **n = 3** (odd)

---

### Step 2 ‚Äî Loop from 3 to ‚àön (only odd numbers)

‚àö3 is approx 1.7 ‚Üí no loop needed
Anything left > 2 is prime:

```
3 > 2 ‚Üí print 3
```

Final factors of 24:

```
2
2
2
3
```

---

# ‚≠ê Example 2: Take **48**

### Step 1 ‚Äî Remove all factors of 2

```
48 % 2 = 0 ‚Üí print 2 ‚Üí n = 24
24 % 2 = 0 ‚Üí print 2 ‚Üí n = 12
12 % 2 = 0 ‚Üí print 2 ‚Üí n = 6
6 % 2 = 0 ‚Üí print 2 ‚Üí n = 3
3 % 2 != 0 ‚Üí stop
```

Printed so far:

```
2
2
2
2
```

### Step 2 ‚Äî Check odd numbers from 3 to ‚àön

‚àö3 = 1.7 ‚Üí loop exits
Remaining number is:

```
3 > 2 ‚Üí print 3
```

Final factors of 48:

```
2
2
2
2
3
```

---

# ‚≠ê Now, Why does the algorithm use these steps?

### ‚úî Step 1:

```java
while (n % 2 == 0) {
    print 2;
    n /= 2;
}
```

**Reason:**
Removing 2's first makes the number **odd** ‚Üí reduces loop workload by 50%.
No need to check even numbers later because only 2 is even prime.

---

### ‚úî Step 2:

```java
for (int i = 3; i * i <= n; i += 2)
```

**Why i += 2?**
We skip even numbers ‚Üí they can never be prime except 2.

**Why i * i <= n?**
If a number has a factor larger than ‚àön,
the matching pair must be smaller than ‚àön.
So checking only up to ‚àön is enough.

This reduces time hugely.

---

### ‚úî Step 3:

```java
if (n > 2) print n;
```

**Why?**
Because after dividing all smaller primes, if something remains,
it must be a prime number.

Example for 24:
We end with `n = 3` ‚Üí print 3.

---

# ‚≠ê Final Summary

| Step                   | Why we do it                              |
| ---------------------- | ----------------------------------------- |
| Remove all 2‚Äôs         | Reduce work, handle only even prime first |
| Check odd numbers only | Skip unnecessary even checks              |
| Check up to ‚àön         | Mathematically enough to find factors     |
| Print remaining n      | If leftover > 2, it's prime               |

---

If you want, I can also explain using a **flow diagram**, or show the **trace (dry run)** for any number you choose!

import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        // Check divisibility from 2 to sqrt(n)
        for (int p = 2; p * p <= n; p++) {
            while (n % p == 0) {
                System.out.println(p);
                n /= p; // remove the factor
            }
        }

        // If remaining n is > 1, it is prime
        if (n > 1) {
            System.out.println(n);
        }
    }
}
13) Write a C++ program to input two numbers from user and find LCM (Lowest Common Multiple).
1 Approach) I wrote this logic 
for (int i = 1; i <= b; i++) { if (a * i % b == 0) { return a * i; } } -- O(b)
for (int i = 1; i <= Math.min(a, b); i++) { --O(min(a,b)
    if (a * i % b == 0) {
        return a * i;
    }
}
2nd approach 
import java.util.*;
public class Main {
	 public static int lcm(int a ,int b) {
		int max;
		if(a > b){
			max = a;
		}
		else {
			max = b;
		}
        int i = max;
		while(true){
          if(i % a  == 0 && i % b  == 0 ) {
			return i;
		  }
		  i = i + max;
		}
	 }
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();
		System.out.println(lcm(a,b));	
	}
} -- O(LCM/max(a,b))
3 rd approach 
 int lcm = Math.max(a, b);

        // Only increase by the max value ‚Üí faster
        while (lcm % a != 0 || lcm % b != 0) {
            lcm += Math.max(a, b);
        }
ime Complexity ‚Äî NOT O(a √ó b)
The loop does not run a * b times.

You increment like this:

lcm = max,  
max*2,  
max*3,  
max*4, ...


So the number of iterations ‚âà LCM / max.

üéØ Complexity = O(LCM / max(a, b))

Let:

LCM(a, b) = Least Common Multiple

max = maximum(a, b)

Then number of iterations is:

[

\text{iterations} = \frac{LCM(a,b)}{\max(a,b)}
]
4th approach (Optimized)



14) Write a C++ program to input two numbers from the user and find HCF (Highest Common Factor) / GCD (Greatest Common Divisor).
import java.util.*;
public class Main {
	 public static int hcf(int a ,int b) {
		int temp ;
		while(b != 0) {
	    temp = a%b;
		a = b;
		b = temp;
		System.out.println(a + " " + b);
		}
		return a;
	 }
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();
		System.out.println(hcf(a,b));	
	}
}
15)Write a C++ program to input two numbers from the user and find HCF (Highest Common Factor) / GCD (Greatest Common Divisor).
Input number1: 12
Input number2: 30
HCF is 6
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        int i, num1, num2, min, hcf = 1;

        // Input two numbers from user
        Scanner scanner = new Scanner(System.in);
        //System.out.println("Enter any two numbers to find HCF:");
        num1 = scanner.nextInt();
        num2 = scanner.nextInt();

        // Find minimum between num1 and num2
        if (num1 < num2) {
            min = num1;
        } else {
            min = num2;
        }

        // Find the HCF by checking for common divisors
        for (i = 1; i <= min; i++) {
            // If 'i' is a divisor of both num1 and num2, it could be the HCF
            if (num1 % i == 0 && num2 % i == 0) {
                hcf = i; // Update HCF
            }
        }

        // Print HCF
        System.out.println("HCF is " + hcf);

        // Close the scanner
        scanner.close();
    }
}
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        int i, num1, num2, min, hcf = 1;

        // Input two numbers from the user
        Scanner scanner = new Scanner(System.in);
        // System.out.println("Enter any two numbers to find HCF:");
        num1 = scanner.nextInt();
        num2 = scanner.nextInt();

        // Find minimum between num1 and num2
        if (num1 < num2) {
            min = num1;
        } else {
            min = num2;
        }

        // Find the HCF by checking for common divisors
        for (i = min; i >= 1; i--) {
            // If 'i' is a divisor of both num1 and num2, it is the HCF
            if (num1 % i == 0 && num2 % i == 0) {
                hcf = i;  // Update HCF
                break;    // Exit the loop once the HCF is found
            }
        }

        // Print the HCF
        System.out.println("HCF is " + hcf);

        // Close the scanner
        scanner.close();
    }
}
16)ARmstrong number
what is my approach means , just every digit take the exponent of number length and add it to sum
use pow function to mutliply that 
import java.util.*;
public class Main {
	public static void main(String[] args) {
		// write your code here
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int len = 0;
		int sum = 0;
		int copy = n;
		while(copy > 0){
			copy = copy/10;
			len++;
		}
		while(n > 0){
			sum = sum + (int)Math.pow(n%10,len);
			n = n/10;
		}
        System.out.println(sum);
	}
}

17)Write a C++ program to input a number and check whether the number is a Perfect number or not.
just what i am thinking means 6 --> iterate from 1 to less than 6  --> i am checking it is is factor or not --> 
if sum = sum + n/i;
1+2+3 = 6 is a perfect number
28 = 1,4,7,14,28
import java.util.*;
public class Main {
	public static void main(String[] args) {
	  Scanner sc = new Scanner(System.in);
	  int n = sc.nextInt();
	  int sum = 0;
	  for(int i=2;i<n;i++){
		if(n%i == 0) {
		sum = sum + n/i;
		}
	  }
	  System.out.println(sum + 1);
	}
}
Perfect üëç
Let‚Äôs **prove clearly with an example where your logic FAILS**, not just works by chance.

---

## üî¥ Your logic (simplified)

```java
for (int i = 2; i < n; i++) {
    if (n % i == 0) {
        sum = sum + (n / i);
    }
}
System.out.println(sum + 1);
```

You are:

* checking `i` is a factor ‚úîÔ∏è
* but **adding `n / i` instead of `i`** ‚ùå
* finally adding `+1` manually

---

## ‚úÖ Case where it *seems* to work (by coincidence)

### Example: **n = 6**

Factors of 6:

```
1, 2, 3
```

Loop execution:

| i | n % i | added (n/i) |
| - | ----- | ----------- |
| 2 | 0     | 3           |
| 3 | 0     | 2           |

`sum = 3 + 2 = 5`
Then `+1` ‚Üí **6** ‚úîÔ∏è

üëâ This works **only because (2,3) are paired divisors**

---

## ‚ùå Case where it FAILS

### üî• Example: **n = 16**

Correct proper divisors of 16:

```
1, 2, 4, 8
Sum = 15
```

### Your loop:

| i | n % i | added (n/i) |
| - | ----- | ----------- |
| 2 | 0     | 8           |
| 4 | 0     | 4           |
| 8 | 0     | 2           |

`sum = 8 + 4 + 2 = 14`
Then `+1` ‚Üí **15**

üò≤ Still correct??

Now watch **WHY THIS IS DANGEROUS**

---

## ‚ùå Real failure case: **Perfect square double counting**

### Example: **n = 36**

Proper divisors:

```
1, 2, 3, 4, 6, 9, 12, 18
Sum = 55
```

### Your loop:

| i  | n % i | added (n/i) |
| -- | ----- | ----------- |
| 2  | 0     | 18          |
| 3  | 0     | 12          |
| 4  | 0     | 9           |
| 6  | 0     | 6 ‚ùå         |
| 9  | 0     | 4           |
| 12 | 0     | 3           |
| 18 | 0     | 2           |

Here is the **bug** üëá

* For `i = 6`, you add `36/6 = 6`
* **Same divisor counted once, but logic breaks symmetry**

This logic **depends on coincidence**, not correctness.

---

## ‚ùå Big logical problem

Your code:

* never explicitly adds `i`
* assumes `n/i` will always cover all divisors correctly
* **breaks clarity and correctness**
* fails badly if modified slightly or optimized

---

## ‚úÖ Correct thinking (THIS is what interviewers want)

### Rule:

> If `i` divides `n`, then **`i` is the divisor** ‚Äî add `i`.

### Clean correct version:

```java
int sum = 0;
for (int i = 1; i <= n / 2; i++) {
    if (n % i == 0) {
        sum += i;
    }
}
```

---

## üß† Final takeaway (important)

* Your logic **sometimes works accidentally**
* Accidental correctness ‚ùå = **wrong logic**
* Always add the **actual divisor (`i`)**
* Use `n/i` only when handling divisor pairs **carefully**

If you want, next I can:

* convert your version to a **correct ‚àön optimized version**
* explain **why 1 must always be included**
* show **abundant / deficient numbers**

Just say üëç


import java.util.*;
public class Main {
	public static boolean perfectNumber(int n) {
	 if(n == 1){
		return false;
	 }
	 int sum = 1;
	  for(int i=2;i*i<=n;i++){
		if(n%i == 0) {
		sum = sum + i;
		 if(i != n/i) {
			sum = sum + n/i;
		 }
		}
	  }
	  return n==sum;
	}
	public static void main(String[] args) {
	  Scanner sc = new Scanner(System.in);
	  int n = sc.nextInt();
	  System.out.println(perfectNumber(n));
}
}
‚úî Time complexity ‚Äî O(‚àön)
‚úî Space complexity ‚Äî O(1)
18)Write a C++ program to input a number from the user and check whether the given number is a strong number or not.
Enter the number: 145
Output
145 is STRONG NUMBER
Approach
To solve this question, we will first see what is a strong number. When we see this term for the first time we don't know what it means. At least I did not know.

What is a Strong Number?

A strong number is a special number whose sum of factorial of digits is equal to the original number.
For example: 145 is a strong number. Since, 1! + 4! + 5! = 145

import java.util.*;
public class Main {
	public static int factorial(int n){
		int fact = 1;
		for(int i=1;i<=n;i++){
			fact = fact * i;
		}
      return fact;
	}
	public static boolean strongNumber(int n) {
	   int sum = 0;
	   int copy = n ;
	   while(n > 0) {
		int p = n % 10;
		sum = sum + factorial(p);
		n = n/10;
	   }
      return copy == sum;
	}
	public static void main(String[] args) {
	  Scanner sc = new Scanner(System.in);
	  int n = sc.nextInt();
	  System.out.println(strongNumber(n));
}
}
Let‚Äôs analyze the **time and space complexity** of your **Strong Number** program step-by-step.

---

## üîπ Code recap (logic)

* Extract each digit of the number
* Compute factorial of each digit
* Add them and compare with original number

---

## ‚è±Ô∏è Time Complexity

Let:

* **d** = number of digits in `n`

### 1Ô∏è‚É£ While loop (digit extraction)

```java
while (n > 0) { ... }
```

Runs **d times** ‚Üí **O(d)**

---

### 2Ô∏è‚É£ Factorial computation

```java
factorial(p)
```

* `p` is a digit (0‚Äì9)
* Max loop runs **9 times**
* Constant time ‚Üí **O(1)**

---

### üî∏ Total Time Complexity

```
O(d √ó 1) = O(d)
```

‚úî Since digits grow as `log‚ÇÅ‚ÇÄ(n)`:

### ‚úÖ Final Time Complexity:

```
O(log n)
```

---

## üíæ Space Complexity

* Only a few integer variables
* No extra data structures

### ‚úÖ Space Complexity:

```
O(1)
```

---

## üîπ With optimization (optional)

If you **precompute factorials of digits 0‚Äì9**:

* Time complexity **still O(log n)**
* But faster in practice (no repeated factorial loops)

---

## üß† One-line exam answer

> Time complexity of Strong Number program is **O(log n)** and space complexity is **O(1)**.

If you want, I can also:

* Compare complexity with **Armstrong Number**
* Optimize factorial using array
* Write code to print all strong numbers in a range

Just tell me üòä

19)Problem 2: Hollow Square Star Pattern
Write a C++ program to print a hollow square star(*) pattern series of N rows.

Write a C++ program to print a square star(*) pattern series of N rows.

Input
Input number of rows: 5
Output
*****
*****
*****
*****
*****
Approach
Look at the pattern for some time. What is coming to your mind??
import java.util.*;
public class Main {
	public static void factorial(int n){
	Scanner sc = new Scanner(System.in);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++) {
		System.out.print("*");
		}
		System.out.println();
	}
   }
   public static void main(String[] args) {
	  Scanner sc = new Scanner(System.in);
	  int n = sc.nextInt(); 
      factorial(5);
   }
}
Problem 2: Hollow Square Star Pattern
Write a C++ program to print a hollow square star(*) pattern series of N rows.
*****
*   *
*   *
*   *
*****
import java.util.*;
public class Main {
	public static void pattern(int n){
	   for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++) {
		 if( i == 1 || i == n || j == 1 || j == n){
              System.out.print("*");
			 }
			 else {
				 System.out.print(" ");
			 }
		 }
		 System.out.println();
	   }
	}

   public static void main(String[] args) {
	  Scanner sc = new Scanner(System.in);
	  int n = sc.nextInt(); 
      pattern(5);
   }
}


20)Write a C++ program to print a hollow square star pattern with diagonals.

Input
Enter number of rows: 5
Output
*****
** **
* * *
** **
*****

Approach
Notice the pattern and try to find the similarity between this pattern and the hollow square pattern. What do you think?? Isn't it similar to the pattern of problem 2? The above pattern is a simple hollow square star pattern if we remove the diagonal. This time we just have 2 extra diagonals. Are we on the same page??
import java.util.*;
public class Main {
	public static void pattern(int n){
	   for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++) {
		 if( i == 1 || i == n || j == 1 || j == n  || i== j || j == n-i+1){
              System.out.print("*");
			 }
			 else {
				 System.out.print(" ");
			 }
		 }
		 System.out.println();
	   }
	}

   public static void main(String[] args) {
	  Scanner sc = new Scanner(System.in);
	  int n = sc.nextInt(); 
      pattern(5);
   }
}
21) Rhombus Star Pattern
Write a C++ program to print a rhombus star pattern of N rows.

Input
Enter number of rows: 5
Output
    *****
   *****
  *****
 *****
*****
Approach
Notice the pattern. Can we correlate this pattern with the pattern of problem 1?? I guess yes we can. The only difference which we can find is in terms of space. If we remove the starting spaces from every row, the pattern will become a square pattern.

Intuition

Have a close look at the pattern. Place your mouse cursor on to the pattern, to count spaces. Try to decode the logic of given pattern.

If we remove leading spaces the pattern becomes a simple square star pattern of N rows and columns. We only need to add logic of printing spaces with the existing logic of square star pattern. How many spaces are there in each row?? Try to figure that out as we will need to print that number of spaces first then stars.

For N=5 as given the output pattern

Row 1: 4 spaces // N-row number=?

Row 2: 3 spaces // N-row number=?

Row 3: 2 spaces // N-row number=?

Row 4: 1 spaces // N-row number=?

Row 5 : 0 spaces // N-row number=?

The pattern consists of N - i spaces per row (where i is the current row number).

 Try it out yourself here!

Explanation/Steps
import java.util.Scanner;

public class StarPattern {
    public static void main(String[] args) {
        int i, j, N; // i --> rows, j --> columns, N --> total rows

        // Input number of rows from the user
        Scanner scanner = new Scanner(System.in);
        //System.out.print("Enter number of rows: ");
        N = scanner.nextInt();

        // Iterate through each row
        for (i = 1; i <= N; i++) {
            // Print leading spaces
            for (j = 1; j <= N - i; j++) {
                System.out.print(" ");
            }

            // Print stars after spaces
            for (j = 1; j <= N; j++) {
                System.out.print("*");
            }

            // Move to the next line after each row
            System.out.println();
        }

        // Close scanner resource
        scanner.close();
    }
}
22)
Mirrored Rhombus Star Pattern
Write a C++ program to print the inverted/mirrored rhombus star pattern of N rows.

Input
Enter number of rows: 5
Output
*****
 *****
  *****
   *****
    *****
Approach
Have you gone through the 4th problem??5th problem and the 4th problem are brothers.üòÖI mean patterns are mirror images of each other. Notice the pattern carefully. We just need to find the relationship between row number and number of spaces. Rest it is similar to 4th problem. Please give it a try guys without looking at the solution. I am very confident that you will be able to arrive at the solution if you have gone through the concept of above problems.üôå

Intuition

Have a close look at the pattern. Place your mouse cursor on to the pattern, to count spaces. Try to decode the logic of given pattern.

We only need to change the logic of printing spaces with the existing logic of rhombus star pattern(4th problem). How many spaces are there in each row?? Try to figure that out as we will need to print that number of spaces first then stars.

For N=5 as given the output pattern

Row 1 : 0 spaces // current row number-1=?(1-1=0)

Row 2: 1 spaces // current row number-1=?(2-1=1)

Row 3 : 2 spaces // current row number-1=?(3-1=2)

Row 4 : 3 spaces // current row number-1=?(4-1=3)

Row 5 : 4 spaces // current row number-1=?(5-1=4)

current row number-1 = Number of spaces in the current row

 If you have noticed there are i - 1 spaces per row (where i is current row number). 

Now give it a try !!

 Try it out yourself here

import java.util.Scanner;

public class StarPattern {
    public static void main(String[] args) {
        int i, j, N; // i --> rows, j --> columns, N --> total rows

        // Input number of rows from the user
        Scanner scanner = new Scanner(System.in);
        //System.out.print("Enter number of rows: ");
        N = scanner.nextInt();

        // Iterate through each row
        for (i = 1; i <= N; i++) {
            // Print leading spaces
            for (j = 1; j < i; j++) {
                System.out.print(" ");
            }

            // Print stars after spaces
            for (j = 1; j <= N; j++) {
                System.out.print("*");
            }

            // Move to the next line after each row
            System.out.println();
        }

        // Close scanner resource
        scanner.close();
    }
}

23)Right Triangle Star Pattern
Write a C++ program to print right triangle star pattern (*) pattern of N rows.

Input
Input number of rows: 5
Output
*
**
***
****
*****
Approach
Look at the pattern for some time. What is coming to your mind??

Intuition

If you look at the pattern carefully you will find that stars are in increasing order of rows.

Row 1: *

Row 2:**

Row 3:***

Row 4:****

Row 5:*****

Noticed something?? Number of stars in a row is same as current row number.

Ask yourself: Iterate through N rows, and for each row how many columns will you iterate?

Hint: Iterate through N rows, and for each row iterate for i ( i is current row number) columns.

Now give it a try !!

Try it out yourself here!

import java.util.Scanner;

public class StarPattern {
    public static void main(String[] args) {
        int i, j, N; // i --> rows, j --> columns, N --> total rows

        // Input total number of rows from the user
        Scanner scanner = new Scanner(System.in);
        //System.out.print("Enter number of rows: ");
        N = scanner.nextInt();

        // Iterate through each row
        for (i = 1; i <= N; i++) {
            // Print i number of stars
            for (j = 1; j <= i; j++) {
                System.out.print("*");
            }

            // Move to the next line after each row
            System.out.println();
        }

        // Close scanner resource
        scanner.close();
    }
}

24)Hollow Right Triangle Star Pattern
Write a C++ program to print hollow right triangle star pattern (*) pattern of N rows.

Input
Input number of rows: 5
Output
*
**
* *
*  *
*****
Approach
Notice the pattern. What do you think?? Isn't it similar to the pattern of problem 1? This time we just have the border of the triangle. Help me in defining "border". This time we just have the stars only for first and last row or first and last column of the pattern of problem 1. Are we on the same page??

Intuition

If you notice carefully, you will find that the logic to print a hollow right triangle is almost similar to right triangle star pattern(problem 1) logic. Just with this pattern you need to print stars only for first and last column or row.

 If we relate to the first problem, we can say that we will need two for loops. One outer loop to iterate over each row and one inner loop to iterate over each column(The inner loop iterates for i times where i is current row number). But this time there will be some changes in inner loop as the star is printed only for specific cases(star is printed only for first or last column or for first or last row).

We basically need to print two things "*"(asterisks) and " "(space). Think of conditions. When you will print what? Print star for first column(j==1), first row(i==1), last column(j==i) or last row(i==N) otherwise print space. Do we need (i==1) compulsorily? No, We can remove that if we want because (j==1) would cater to that condition as well. Why condition for last column is j==i ??Dry run on an example and you are good to go.

Now give it a try !!
import java.util.Scanner;

public class StarPattern {
    public static void main(String[] args) {
        int i, j, N; // i --> rows, j --> columns, N --> total rows

        // Input number of rows from the user
        Scanner scanner = new Scanner(System.in);
        //System.out.print("Enter number of rows: ");
        N = scanner.nextInt();

        // Iterate through N rows
        for (i = 1; i <= N; i++) {

            // Iterate through each column
            for (j = 1; j <= i; j++) {
                /*
                 * Print star for:
                 * - first column (j == 1)
                 * - first row (i == 1)
                 * - last column (j == i)
                 * - last row (i == N)
                 */
                if (i == 1 || j == 1 || j == i || i == N) {
                    System.out.print("*");
                } else {
                    System.out.print(" ");
                }
            }

            // Move to the next line after each row
            System.out.println();
        }

        // Close scanner resource
        scanner.close();
    }
}

25) Mirrored Right Triangle Star Pattern
Write a C++ program to print mirrored right triangle star pattern (*) pattern of N rows.

Input
Input number of rows: 5
Output
    *
   **
  ***
 ****
*****
Approach
Have you gone through the first problem?? The pattern of this problem and the first problem are mirror images of each other. Notice the pattern carefully. We just need to find the relationship between row number and number of spaces in that row. Please give it a try guys without looking at the solution. I am very confident that you will be able to arrive at the solution.üôå

Intuition

Have a close look at the pattern. Place your mouse cursor on to the pattern, to count spaces. Try to decode the logic of given pattern. We only need to change the logic of printing spaces with the existing logic of the right triangle star pattern(1st problem). How many spaces are there in each row?? Try to figure that out as we will need to print that number of spaces first then stars.

For N=5 as given the output pattern

Row 1 : 4 spaces // N-current row number=?(5-1=4)

Row 2: 3 spaces // N-current row number=?(5-2=3)

Row 3 : 2 spaces // N-current row number=?(5-3=2)

Row 4 : 1 spaces // N-current row number=?(5-4=1)

Row 5 : 0 spaces // N-current row number=?(5-5=0)

N - current row number = Number of spaces in the current row

Now give it a try !!
import java.util.Scanner;

public class StarPattern {
    public static void main(String[] args) {
        int i, j, N; // i --> rows, j --> columns, N --> total rows

        // Input number of rows from the user
        Scanner scanner = new Scanner(System.in);
        // System.out.print("Enter number of rows: ");
        N = scanner.nextInt();

        // Iterate through rows
        for (i = 1; i <= N; i++) {
            // Print leading spaces
            for (j = 1; j <= N - i; j++) {
                System.out.print(" ");
            }

            // Print stars after spaces
            for (j = 1; j <= i; j++) {
                System.out.print("*");
            }

            // Move to the next line after each row
            System.out.println();
        }

        // Close scanner resource
        scanner.close();
    }
}

27)Hollow Mirrored Right Triangle Star Pattern
Write a C++ program to print hollow mirrored right triangle star pattern (*) pattern of N rows.

Input
Input number of rows: 5
Output
    *
   **
  * *
 *  *
*****
Approach
Notice the pattern. What do you think?? Isn't it similar to the pattern of problem 3? This time we just have the border of the mirrored right triangle star pattern. The above pattern is almost similar to mirrored right triangle star pattern(problem 3) with stars printed only for first or last column and for first or last row. Is it getting difficult ??üòµ‚Äçüí´ü•πIf yes please take a small break.

Don't you think this is the mix of problem 2(hollow right triangle star pattern) and problem 3(mirrored right triangle star pattern)?? Once go through both these problems then Give it a shot !!

Intuition

The above pattern is similar to mirrored right triangle star pattern with stars printed only for first or last column and for first or last row. (If you remember üôÇ we had a similar condition in problem 2 as well where stars were printed only for first or last column and for first or last row)

We will iterate through N rows. For each row, First, we will print the leading spaces and then we can use logic of hollow right triangle star pattern(problem 2). And then we will get our pattern. Make sense or not?? I hope yes‚úåÔ∏è.

Now please give it a try !! If you get the solution by just reading the intuition. Congratulationsü•≥ü´°. Otherwise, definitely, we can refer to the solution.

 Try it out yourself here!

Guys, for this problem I would strongly suggest even if you are referring to the solution please use your pen and paper and dry run each step with an example. Trust me it will be much more clear if you are facing difficulty at any step.

Expla
import java.util.Scanner;

public class HollowRightTriangle {
    public static void main(String[] args) {
        int i, j, N; // i --> rows, j --> columns, N --> total rows

        // Input number of rows from the user
        Scanner scanner = new Scanner(System.in);
        //System.out.print("Enter number of rows: ");
        N = scanner.nextInt();

        // Iterate through rows
        for (i = 1; i <= N; i++) {
            // Print leading spaces
            for (j = i; j < N; j++) {
                System.out.print(" ");
            }

            // Print hollow right triangle
            for (j = 1; j <= i; j++) {
                /*
                 * Print star for:
                 * - first row (i == 1),
                 * - last row (i == N),
                 * - first column (j == 1),
                 * - last column (j == i)
                 */
                if (i == 1 || i == N || j == 1 || j == i) {
                    System.out.print("*");
                } else {
                    System.out.print(" ");
                }
            }

            // Move to the next line after each row
            System.out.println();
        }

        // Close scanner resource
        scanner.close();
    }
}
28)Inverted Right Triangle Star Pattern
Write a C++ program to print inverted right triangle star pattern (*) pattern of N rows.

Input
Input number of rows: 5
Output
*****
****
***
**
*
Approach
This will be our last question for this exercise. I am confident this question will be a piece of cake for you if you have gone through the above questions. Can we correlate this problem with problem 1?? Try it once without looking at the solutionüôÇ

Intuition

If you look at the pattern carefully you will find that stars are in increasing order of rows.

For N=5(where N is the total number of rows or input)

Row 1 : ***** -> N stars = N-1+1 stars

Row 2 :**** ->N-1 stars = N-2+1 stars

Row 3 :*** ->N-2 stars = N-3+1 stars

Row 4 :** ->N-3 stars = N-4+1 stars

Row 5 :* ->N-4 stars = N-5+1 stars

Noticed something? Number of stars in a row = N - current row number +1.

Ask yourself: Iterate through N rows, and for each row how many columns will you iterate?

Hint: Iterate through N rows, and for each row iterate for N-i+1 columns(i is current row number).

Now give it a try !!
import java.util.Scanner;

public class LeftAlignedTriangle {
    public static void main(String[] args) {
        int i, j, N; // i --> rows, j --> columns, N --> total rows

        // Input number of rows from the user
        Scanner scanner = new Scanner(System.in);
        // System.out.print("Enter number of rows: ");
        N = scanner.nextInt();

        // Iterate through rows
        for (i = 1; i <= N; i++) {
            // Iterate through columns
            for (j = 1; j <= N - i + 1; j++) {
                System.out.print("*");
            }
            // Move to the next line after each row
            System.out.println();
        }

        // Close scanner resource
        scanner.close();
    }
}
29)Pyramid Star Pattern
Write a C++ program to print Pyramid star( equilateral triangle ) pattern of N rows.

Input
Input number of rows: 5
Output
    *
   ***
  *****
 *******
*********
Before you read further have a close look at the above pattern. And note down your observations.
Pattern consists of N (for this case 5) rows. Each row contains 2*i-1(where i is the current row number) stars. In addition to stars, the pattern has leading spaces. Each row contains some spaces. To count total spaces per row point your mouse over the above pattern. How many leading spaces are there in each row?? Try to figure that out as we will need to print that number of spaces first then stars.

For N=5 as given the output pattern

Row 1: 4 spaces // N-current row number=?(5-1=4)

Row 2: 3 spaces // N-current row number=?(5-2=3)

Row 3: 2 spaces // N-current row number=?(5-3=2)

Row 4: 1 spaces // N-current row number=?(5-4=1)

Row 5: 0 spaces // N-current row number=?(5-5=0)

N - current row number = Number of spaces in the current row

Now give it a try !!
import java.util.Scanner;

public class StarPyramid {
    public static void main(String[] args) {
        int i, j, N; // i --> rows, j --> columns, N --> total rows

        // Input number of rows from the user
        Scanner scanner = new Scanner(System.in);
        //System.out.print("Enter number of rows: ");
        N = scanner.nextInt();

        // Iterate through rows
        for (i = 1; i <= N; i++) {
            // Print leading spaces
            for (j = 1; j <= N - i; j++) {
                System.out.print(" ");
            }

            // Print stars
            for (j = 1; j <= (2 * i - 1); j++) {
                System.out.print("*");
            }

            // Move to the next line after each row
            System.out.println();
        }

        // Close scanner resource
        scanner.close();
    }
}

30)Hollow Pyramid Star Pattern
Write a C++ program to print hollow pyramid star pattern (*) pattern of N rows.

Input
Input number of rows: 5
Output
    *
   * *
  *   *
 *     *
*********
Approach
Notice the pattern. What do you think?? Isn't it similar to the pattern of problem 1? This time we just have the border of the pyramid. Help me in defining "border". This time we just have the stars only for first and last row or first and last column of the pattern of problem 1. Can we give it a shot now??

Intuition

If you notice carefully, you will find that the logic to print a hollow pyramid is almost similar to the pyramid star pattern(problem 1) logic. Just with this pattern you need to print stars only for the first column, last column, first row and last row.

 If we relate to the first problem, in addition to stars, the pattern had leading spaces before the stars in each row. Each row contains some leading spaces. To count the total leading spaces per row point your mouse over the above pattern. How many leading spaces are there in each row?? There are N-i( i is the current row number) leading spaces. (We have already found this in Intuition of problem 1).

Iterate over N rows and first print leading spaces in every row. How will you print leading spaces? Hint: Use a for loop 

After printing the leading spaces, now start with the logic to print hollow pyramid. At max, there can be (2*i-1) stars in row. We basically need to print two things "*"(asterisks) and " "(space) now. Think of conditions. When you will print what? Print star for the first column(j==1), first row(i==1), last column(j==2*i-1) or last row(i==N) otherwise print space. Do we need (i==1) compulsorily? No, We can remove that if we want because (j==1) would cater to that condition as well.

Now give it a try !!
import java.util.Scanner;

public class HollowPyramid {
    public static void main(String[] args) {
        int i, j, N; // i --> rows, j --> columns, N --> total rows

        // Input number of rows from the user
        Scanner scanner = new Scanner(System.in);
        //System.out.print("Enter number of rows: ");
        N = scanner.nextInt();

        // Iterate through rows
        for (i = 1; i <= N; i++) {
            // Print leading spaces
            for (j = 1; j <= N - i; j++) {
                System.out.print(" ");
            }

            // Print hollow pyramid
            for (j = 1; j <= (2 * i - 1); j++) {
                // Print stars for the first row, last row, and edges of the pyramid
                if (i == 1 || i == N || j == 1 || j == (2 * i - 1)) {
                    System.out.print("*");
                } else {
                    System.out.print(" ");
                }
            }

            // Move to the next line after each row
            System.out.println();
        }

        // Close scanner resource
        scanner.close();
    }
}

31) Inverted Pyramid Star Pattern
Write a C++ program to print inverted Pyramid star pattern for N rows.

Input
Input number of rows: 5
Output
*********
 *******
  *****
   ***
    *  
Approach
Have you gone through the first problem?? The pattern of this problem and the first problem are the water images of each other. Notice the pattern carefully. Please give it a try guys without looking at the solution. The approach is similar to problem 1. I am very confident that you will be able to solve it on your own.üôå
Pattern consists of N (for this case 5) rows. 

To solve this question, we essentially need to find two things :

1)Relationship between current row number and leading spaces in that row

2)Relationship between current row number and number of stars in that row

Take out your pen and paper and try to find out the above two things.

The pattern consists of leading spaces. Each row contains i ‚Äì 1 leading space (where i is the current row number).

Each row has exactly 2 * N - (2 * i - 1) stars.

Now give it a try !!
import java.util.Scanner;

public class InvertedHollowPyramid {
    public static void main(String[] args) {
        int i, j, N; // i --> rows, j --> columns, N --> total rows

        // Input number of rows from the user
        Scanner scanner = new Scanner(System.in);
       // System.out.print("Enter number of rows: ");
        N = scanner.nextInt();

        // Iterate through rows
        for (i = 1; i <= N; i++) {
            // Print leading spaces
            for (j = 1; j < i; j++) {
                System.out.print(" ");
            }

            // Print stars
            for (j = 1; j <= (2 * N - (2 * i - 1)); j++) {
                System.out.print("*");
            }

            // Move to the next line after each row
            System.out.println();
        }

        // Close the scanner resource
        scanner.close();
    }
}

Hollow Inverted Pyramid Star Pattern
32)Write a C++ program to print hollow inverted Pyramid star pattern for N rows.

Input
Input number of rows: 5
Output
*********
 *     *
  *   *
   * *
    *
Approach
Notice the pattern. What do you think?? Isn't it similar to the pattern of problem 3? This time we just have the border of the inverted pyramid star pattern. The above pattern is almost similar to the inverted pyramid star pattern(problem 3) with stars printed only for first or last column and for first or
last row. Is it getting too difficult ??üòµ‚Äçüí´ü•πIf yes please take a small break and then come back.
The above pattern is similar to inverted pyramid star pattern with stars printed only for first or last column and for first or last row.(If you remember üôÇ we had a similar condition in problem 2 as well where stars were printed only for first or last column and for first or last row)

We will iterate through N rows. For each row, First, we will print the leading spaces and then we can use logic of hollow pyramid star pattern(problem 2). And then we will get our pattern. Make sense or not?? I hope yes‚úåÔ∏è.

Now please give it a try !! If you get the solution by just reading the intuition. Congratulationsü•≥ü´°. Otherwise, definitely, we can refer to the solution.


Don't you think this is the mix of problem 2(hollow pyramid star pattern) and problem 3( inverted pyramid star pattern)?? Once go through both these problems then Give it a shot !! It will also help you in analysing the understanding of those problems and implementing those concepts.

import java.util.Scanner;

public class HollowPyramid {
    public static void main(String[] args) {
        int i, j, N; // i --> rows, j --> columns, N --> total rows

        // Input number of rows from the user
        Scanner scanner = new Scanner(System.in);
       // System.out.print("Enter number of rows: ");
        N = scanner.nextInt();

        // Iterate through rows
        for (i = 1; i <= N; i++) {
            // Print leading spaces
            for (j = 1; j < i; j++) {
                System.out.print(" ");
            }

            // Print hollow pyramid
            for (j = 1; j <= (2 * N - (2 * i - 1)); j++) {
                // Print stars for the first row, last row, and the edges of the pyramid
                if (i == 1 || i == N || j == 1 || j == (2 * N - (2 * i - 1))) {
                    System.out.print("*");
                } else {
                    System.out.print(" ");
                }
            }

            // Move to the next line after each row
            System.out.println();
        }

        // Close the scanner resource
        scanner.close();
    }
}
 Diamond Star Pattern
Write a C++ program to print diamond star pattern for N rows.

Input
Input number of rows: 5

33) Diamond Star Pattern
Write a C++ program to print diamond star pattern for N rows.

Input
Input number of rows: 5
    *
   ***
  *****
 *******
*********
 *******
  *****
   ***
    *
Approach
Before you read further have a close look at the above pattern. And note down your observations. Try to solve it on your own as we covered the concept in previous articles.üôÇ

Intuition

The given pattern is a combination of pyramid star pattern and inverted pyramid star pattern. It consists of 2*N-1 rows (for this case N=5). Each row contains spaces and stars printed in increasing and decreasing order.

Stars are printed in increasing order till the Nth row. After Nth row stars are printed in decreasing order.

Spaces are printed in decreasing order till the Nth row. After the Nth row spaces are printed in increasing order. Point your mouse cursor over the pattern to count total spaces.

Now give it a try guys we have already solved various problems on similar lines in previous articles. I am very confident you will be able to solve it.üòÄ
#include <iostream>
using namespace std;

int main()
{
    int i, j, N;
    int stars, spaces;
   
    // Input number of rows from user 
    cout<<"Enter number of rows to print: "<<endl;
    cin>>N;
    
    
    stars = 1;
    spaces = N - 1;
    
    /* Iterate through rows */
    for(i=1; i<2*N; i++)
    {
        /* Print spaces */
        for(j=1; j<=spaces; j++)
            cout<<" ";
        
        /* Print stars */
        for(j=1; j<stars*2; j++)
            cout<<"*";
        
        /* Move to next line */
        cout<<endl;
        
        if(i<N)
        {
            spaces--;
            stars++;
        }
        else
        {
            spaces++;
            stars--;
        }
    }
    
    return 0;
}

34) Right Arrow Star Pattern
Write a C++ program to print right arrow star pattern.
my approach according to pattern i used spaces and stars
import java.util.*;
public class Main {
	public static void main(String[] args) {
		// write your code here
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int stars = n;
		int spaces = 0;
		for(int i=1;i<2*n;i++){
			for(int j=1;j<=spaces;j++){
               System.out.print(" ");
			}
			for(int k=1;k<=stars;k++){
               System.out.print("*");
			}
			System.out.println();
			if(i < n){
				stars--;
				spaces++;
			}
			else {
				stars++;
				spaces--;
			}
		}
	}
}
space complexity : O(n2)
time complexity: O(1)

35)Write a C++ program to print plus sign pattern.
Input number of rows: 5
Output
    +
    +
    +
    +
+++++++++
    +
    +
    +
    +
approach: just observe the pattern
import java.util.*;
public class Main {
	public static void main(String[] args) {
		// write your code here
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int size = 2*n-1;
		int mid = n;
		for(int i=1;i<=size;i++){
			for(int j=1;j<=size;j++){
                 if(i == mid || j == mid) {
                  System.out.print("*");
				 }
				 else {
                   System.out.print(" ");
				 }
			}
			System.out.println();
			}
		}
	}
‚è±Ô∏è Time & Space Complexity

Time Complexity: O(n¬≤)
(You print (2n‚àí1) √ó (2n‚àí1) characters)

Space Complexity: O(1)

*       *
 *     *
  *   *
   * *
    *
   * *
  *   *
 *     *
*       *
36)import java.util.*;
public class Main
{
	public static void main(String[] args) {
	 Scanner sc = new Scanner(System.in);
	 int n = sc.nextInt();
	 for(int i=1;i<2*n;i++){
	     for(int j=1;j<2*n;j++){
	        if(i == j || j == 2*n -i){
	            System.out.print("*");
	        }
	        else {
	            System.out.print(" ");
	        }
	    } 
	    System.out.println();
	 }
	}
}
‚è±Ô∏è Time & Space Complexity

Time Complexity: O(n¬≤)
Space Complexity: O(1) (no extra space used)

for Readability
int size = 2*n - 1;
for(int i = 1; i <= size; i++){
    for(int j = 1; j <= size; j++){
        if(i == j || j == size - i + 1)
            System.out.print("*");
        else
            System.out.print(" ");
    }
    System.out.println();
}
37)Write a C++ program to print 8 star pattern of N rows.
Input number of columns: 5
 ***
*   *
*   *
*   *
 ***
*   *
*   *
*   *
 ***
#include <iostream>
using namespace std;

int main()
{
    int i, j, N; // i--> rows , j-->columns , N-->size

    // Input total number of rows from user 
    cout<<"Enter size: "<<endl;
    cin>>N;

    for(i=1; i<N*2; i++)
    {
        for(j=1; j<=N; j++)
        {
            // Condition for corner and center intersection space
            if((i==1 && (j==1 || j==N)) || 
               (i==N && (j==1 || j==N)) || 
               (i==N*2-1 && (j==1 || j==N)))
            {
                cout<<" ";
            }
            else if(i==1 || i==N || i==(N*2)-1 || j==1 || j==N)
            {
                cout<<"*";
            }
            else
            {
                cout<<" ";
            }
        }

        cout<<endl;
    }

    return 0;
}
Got it üëç
Let me explain this **very clearly and slowly**, without jumping steps.

---

## 1Ô∏è‚É£ What is the goal of this program?

This program prints **three hollow rectangles (or boxes) stacked vertically**.

* Width of each box = `N`
* Height of each box = `1` row (top, middle, bottom borders)
* Total rows printed = `2*N - 1`

For **N = 5**, output looks like:

```
 ***
*   *
*   *
*   *
 ***
*   *
*   *
*   *
 ***
```

---

## 2Ô∏è‚É£ Understanding the loops

### üîπ Outer loop (rows)

```cpp
for(i = 1; i < N*2; i++)
```

* Runs from `1` to `2*N - 1`
* So total rows = `2*N - 1`

Important rows:

* `i == 1` ‚Üí top border
* `i == N` ‚Üí middle border
* `i == 2*N - 1` ‚Üí bottom border

These three rows form the **horizontal lines** of the boxes.

---

### üîπ Inner loop (columns)

```cpp
for(j = 1; j <= N; j++)
```

* Prints exactly `N` characters per row
* `j == 1` ‚Üí first column
* `j == N` ‚Üí last column

These columns form the **vertical borders**.

---

## 3Ô∏è‚É£ First `if` condition (corner spaces)

```cpp
if ((i==1 && (j==1 || j==N)) ||
    (i==N && (j==1 || j==N)) ||
    (i==N*2-1 && (j==1 || j==N)))
{
    cout << " ";
}
```

### ‚ùì What does this mean?

This checks **corners of the top, middle, and bottom borders**.

Rows checked:

* `i == 1`
* `i == N`
* `i == 2*N - 1`

Columns checked:

* `j == 1` (left corner)
* `j == N` (right corner)

### ‚úÖ Why print space here?

Look at the top row:

```
 ***
```

* First and last positions must be **spaces**
* Otherwise it becomes a filled rectangle

So this condition **removes stars from the corners**.

---

## 4Ô∏è‚É£ Second condition (print borders)

```cpp
else if (i==1 || i==N || i==(N*2)-1 || j==1 || j==N)
{
    cout << "*";
}
```

### ‚ùì What does this do?

Prints `*` when:

* Row is a border (`1`, `N`, `2N-1`)
* OR column is a border (`1` or `N`)

This creates:

* Top border
* Middle border
* Bottom border
* Left side wall
* Right side wall

Together ‚Üí **hollow box outline**

---

## 5Ô∏è‚É£ Last `else` (inside space)

```cpp
else
{
    cout << " ";
}
```

This runs when:

* Not a border
* Not a corner

So it prints **spaces inside the box**.

That‚Äôs what makes the box **hollow**.

---

## 6Ô∏è‚É£ Example walkthrough (N = 5)

### Row 1 (`i = 1`)

* Corners ‚Üí space
* Middle ‚Üí stars

Output:

```
 ***
```

---

### Row 2‚Äì4 (`i = 2,3,4`)

* `j == 1` or `j == 5` ‚Üí `*`
* Middle ‚Üí space

Output:

```
*   *
```

---

### Row 5 (`i = N`)

Same as row 1:

```
 ***
```

---

### Row 9 (`i = 2*N - 1`)

Again same:

```
 ***
```

---

## 7Ô∏è‚É£ Time Complexity

* Outer loop ‚Üí `O(N)`
* Inner loop ‚Üí `O(N)`
* Total complexity ‚Üí **`O(N¬≤)`**

---

## üîë Final understanding

* **Outer loop** ‚Üí controls rows
* **Inner loop** ‚Üí controls columns
* **First if** ‚Üí removes corner stars
* **Second if** ‚Üí draws borders
* **Else** ‚Üí fills empty space

---

If you want, next I can:

* rewrite this with **simpler logic**
* show how to **design such patterns step-by-step**
* convert it to **Java clean version**

Just tell üëç
else if (i==1 || i==N || i==(N*2)-1 || j==1 || j==N)
{
    cout << "*";
}
we have to print space know in if block we printing the same

Very good question üëç
This confusion is **very common** when learning pattern logic.
Let‚Äôs clear it **cleanly and logically**.

---

## üî¥ Your confusion

You‚Äôre asking:

> **‚ÄúIn the `if` block we already print space,
> then in `else if` we are again covering the same rows (`i==1`, `i==N`, `i==2N-1`).
> Why are we printing `*` again?‚Äù**

‚úÖ This is **intentional** and **correct**.

---

## üîë Key idea you must remember

### ‚ùó `if ‚Äì else if` works in ORDER

Once an `if` condition is true, **Java/C++ never checks the `else if`**.

---

## üîç Let‚Äôs see the exact logic

### Code:

```cpp
if ((i==1 && (j==1 || j==N)) ||
    (i==N && (j==1 || j==N)) ||
    (i==2*N-1 && (j==1 || j==N)))
{
    cout << " ";
}
else if (i==1 || i==N || i==(2*N-1) || j==1 || j==N)
{
    cout << "*";
}
else
{
    cout << " ";
}
```

---

## üß† Why this is written like this

### Step 1Ô∏è‚É£ Handle **special corner cases first**

These positions:

* `(1,1) , (1,N)`
* `(N,1) , (N,N)`
* `(2N-1,1) , (2N-1,N)`

üìå These are **corners** ‚Üí they must be **spaces**, not stars

So we **catch them first**.

---

### Step 2Ô∏è‚É£ Handle general border stars

Now for all **other border positions**:

* Top row ‚Üí `i == 1`
* Middle row ‚Üí `i == N`
* Bottom row ‚Üí `i == 2N-1`
* Left wall ‚Üí `j == 1`
* Right wall ‚Üí `j == N`

These should be `*`.

But ‚ö†Ô∏è **corners are already removed above**, so no conflict.

---

## üìå Example (N = 5)

Let‚Äôs check **row 1, column 1** `(i=1, j=1)`:

* First `if` ‚Üí ‚úÖ TRUE ‚Üí prints `" "`
* `else if` ‚Üí ‚ùå NOT checked

Correct output:

```
 ***
```

---

### Now check `(i=1, j=3)`:

* First `if` ‚Üí ‚ùå false
* Second `else if` ‚Üí ‚úÖ true ‚Üí prints `"*"`

Correct.

---

### Check `(i=3, j=1)`:

* First `if` ‚Üí ‚ùå false
* Second `else if` ‚Üí ‚úÖ true ‚Üí prints `"*"`

Correct vertical wall.

---

## üîÅ Why not remove `i==1` from else-if?

Because:

* You **still want stars** in row `i==1`
* Except at **corners**, which are already handled

---

## üß† Mental model (VERY IMPORTANT)

Think like this:

> üîπ **First remove exceptions (corners)**
> üîπ **Then draw general borders**
> üîπ **Else ‚Üí empty space**

This is a **standard pattern-design technique**.

---

## ‚úÖ Final conclusion

‚úî Yes, both conditions mention `i==1`, `i==N`, etc.
‚úî But **order matters**
‚úî Corners are filtered FIRST
‚úî Remaining borders are stars
‚úî Inside is space

---

--> Number Patterns

38)Write a program to print 0s and 1s at alternate rows.
Input

rows = 6
cols = 5

11111
00000
11111
00000
11111
00000

import java.util.*;
   public class Main
   {
	public static void main(String[] args) {
	 Scanner sc = new Scanner(System.in);
	 int n = sc.nextInt();
	 for(int i=1;i<=n;i++){
	     for(int j =1;j<=n;j++){
	         if(i%2 == 1){
	           System.out.print("1");   
	         }
	         else {
	             System.out.print("0");     
	         }
	     }
	     System.out.println();
     }
}
}

39)Print 1, 0 number pattern at alternate columns
Write a program to print 0s and 1s at alternate columns.

Input

rows = 6
cols = 5
Output

01010
01010
01010
01010
01010
01010

import java.util.*;
   public class Main
   {
	public static void main(String[] args) {
	 Scanner sc = new Scanner(System.in);
	 int n = sc.nextInt();
	 for(int i=1;i<=n;i++){
	     for(int j =1;j<=n;j++){
	         if(j%2 == 1){
	           System.out.print("0");   
	         }
	         else {
	             System.out.print("1");     
	         }
	     }
	     System.out.println();
     }
}
}

 Print box number pattern of 1s and 0s
Input

rows = 6
cols = 5
Output

40)
11111
10001
10001
10001
10001
11111


import java.util.*;
   public class Main
   {
	public static void main(String[] args) {
	 Scanner sc = new Scanner(System.in);
	 int rows = sc.nextInt();
	 int columns = sc.nextInt();
	 for(int i=1;i<=rows;i++){
	     for(int j = 1; j<=columns;j++){
	         if(i == 1 || i == rows || j == 1 || j == columns){
	            System.out.print("1"); 
	         }
	         else {
	            System.out.print("0");  
	         }
	     }
	     System.out.println();
	 }
   }
}




Time & Space Complexity

Time Complexity:

O(rows√ócolumns)

Space Complexity:

ùëÇ(1)


(No extra memory used)

41)Pattern 4: Print chessboard number pattern with 1 and 0
Input

rows = 5
cols = 5
Output

10101
01010
10101
01010
10101
Intuition

Try to think the above pattern as a matrix where 1 and 0 is printed at every alternate element. Hence we need to track the alternate positions and print the value accordingly. Now the question arises that how can we track this? 

To keep track of alternate element, we will use an extra variable k. k will have 2 values and k's value will decide that what we should print. 

Let's say k can have two possible values i.e. -1 and 1. For k = 1, we'll print 1 otherwise print 0. Hence initially k value would be 1 so we'll print 1. Since we need to print alternate elements, we'll change the value of to -1. Next time, when we check the value of k, it'll be -1 and so we'll print 0. We'll again change k's value and repeat this step after printing pattern's value everytime.

Logic

Input number of rows and columns to print from user. Store it in some variable say rows and cols.
Initialize a variable to keep track of alternate element, say k = 1.
To iterate through rows run an outer loop from 1 to rows. 
To iterate through columns run an inner loop from 1 to cols. 
Inside the inner loop print 1, 0 for alternate elements. Say if(k == 1) then print 1 otherwise 0. After printing change the value of k = k * -1.
Note: Multiplying 1 with -1 gives -1 and -1 with -1 gives 1. You can remember this as a short trick for flipping values rather than applying if else condition : )
Finally, move to next line after printing all columns of a row.
Sol
import java.util.*;
   public class Main
   {
	public static void main(String[] args) {
	 Scanner sc = new Scanner(System.in);
	 int rows = sc.nextInt();
	 int cols = sc.nextInt();
	 int k = 1;
	 for(int i=1;i<=rows;i++){
	     for(int j=1; j <= cols;j++){
	         if(k == 1){
	             System.out.print("1");
	         }
	         else {
	             System.out.print("0");
	         }
	         k = k*-1;
	     }
	     System.out.println();
	     if(cols % 2 == 0){
	         k = k*-1;
	     }
	 }
	 
   }
}
O(rows*cols) 
O(1)





